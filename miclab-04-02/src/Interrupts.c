//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8BB1_Register_Enums.h>

#define LED_ON 0
#define LED_OFF 1
#define FIRST_LETTER 0
#define NO_WAIT 0
#define SHORT_WAIT 1
#define LONG_WAIT 3
#define WORD_WAIT 10
#define ONBOARD_LED P1_B4
#define ONBOARD_BTN P0_B2

enum {
	DOT_ON, DOT_OFF,
	DASH_ON, DASH_OFF,
	LETTER_PAUSE, WORD_PAUSE
};

// Current state
extern uint16_t morseState = DOT_ON;
// Timer for longer operations (DASH)
extern uint16_t morseCounter = 0;
// Where we are in SOS
extern uint16_t letterIndex = 0;

const unsigned char morsePattern[] = {
	DOT_ON, DOT_OFF, DOT_ON, DOT_OFF, DOT_ON, DOT_OFF, // S = ...
	LETTER_PAUSE, // Pause between S and O
	DASH_ON, DASH_OFF, DASH_ON, DASH_OFF, DASH_ON, DASH_OFF, // O = ---
	LETTER_PAUSE, // Pause between O and S
	DOT_ON, DOT_OFF, DOT_ON, DOT_OFF, DOT_ON, DOT_OFF, // S = ...
	WORD_PAUSE // Word pause after SOS 2s
};

//-----------------------------------------------------------------------------
// TIMER2_ISR
//-----------------------------------------------------------------------------
//
// TIMER2 ISR Content goes here. Remember to clear flag bits:
// TMR2CN0::TF2H (Timer # High Byte Overflow Flag)
// TMR2CN0::TF2L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
{
	TMR2CN0_TF2H = 0; // Clear the timer interrupt flag

	switch (morseState)
	{
		case DOT_ON:
			ONBOARD_LED = LED_ON;
			morseCounter = NO_WAIT;
			morseState = DOT_OFF;

			break;

		case DOT_OFF:
			ONBOARD_LED = LED_OFF;
			morseCounter = NO_WAIT;
			letterIndex++;
			morseState = morsePattern[letterIndex];

			break;

		case DASH_ON:
			ONBOARD_LED = LED_ON;

			if (morseCounter >= LONG_WAIT)
			{
				morseState = DASH_OFF;
				morseCounter = NO_WAIT;
			}
			else
			{
				morseCounter += SHORT_WAIT;
			}

			break;
		case DASH_OFF:
			ONBOARD_LED = LED_OFF;
			morseCounter = NO_WAIT;
			letterIndex++;
			morseState = morsePattern[letterIndex];

			break;
		case LETTER_PAUSE:
			ONBOARD_LED = LED_OFF;

			if (morseCounter >= LONG_WAIT)
			{
				morseCounter = NO_WAIT;
				letterIndex++;
				morseState = morsePattern[letterIndex];
			}
			else
			{
				morseCounter += SHORT_WAIT;
			}

			break;
		case WORD_PAUSE:
			ONBOARD_LED = LED_OFF;

			if (morseCounter >= WORD_PAUSE)
			{
				morseCounter = NO_WAIT;
				letterIndex = FIRST_LETTER;
				morseState = morsePattern[letterIndex];
			}
			else
			{
				morseCounter += SHORT_WAIT;
			}

			break;
		default:
			break;
	}
}

